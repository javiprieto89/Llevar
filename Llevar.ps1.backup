# *********************************************************************************************
# SE MANTIENE POR COMPATIBILIDAD CON LA TERCERA EDAD LO VIEJO SIRVE JUAN ehhhhhh ALEJANDRO xD #
# ********************************************************************************************* 
# Con el mayor de los respetos, para alguien por el que siempre senti mucha admiración, a modo homenaje, 
# espero que te guste esta loca vuelta de tuercaal mítico LLEVAR.BAT que tanto me ayudó en mis comienzos con 
#MS-DOS y me guio por este hermoso camino que me  ha dado de comer por tanto tiempo


# *** Versión 1.83 del LLEVAR, por Alex Soft ***
# *** Compatible con Windows 2000 / ARJ32 ***
# *** Hasta 30 diskettes / Nueva instalación ***
# *** Arreglado por fin el problema al instalar ***
# *** Ahora con soporte para volver a llevar ***
# *** Borrado DOBLE de diskettes en Windows 2000 ***

# Este BAT fue creado durante el transcurso de un curso de DOS,
# y con el único propósito de explicar la utilización de diversos comandos.
# Por esa razón fue modificado numerosas veces durante las clases y en
# muchas otras ocasiones.

# Esa es la razón o "excusa" para justificar la desprolijidad del código >;-)

# No obstante, creo que esta pequeña utilidad es LO MEJOR para transportar
# cosas que ocuparían más de 1 diskette. Eso sí, tiene un límite de 30 diskettes,
# pero te avisa ANTES si te pasás.

# Los archivos necesarios son:
#   - LLEVAR.BAT
#   - ASK.EXE
#   - ARJ.EXE
#   - ARJ32.EXE

<#
.SYNOPSIS
    LLEVAR-USB - Sistema de transporte de carpetas en múltiples dispositivos USB
    Versión PowerShell moderna del clásico LLEVAR.BAT de Alex Soft

.DESCRIPTION
    LLEVAR-USB permite transportar carpetas grandes dividiéndolas en múltiples bloques
    que pueden distribuirse en varios dispositivos USB. Es ideal cuando:
    - La carpeta es muy grande para un solo USB
    - No hay conexión a internet/red para transferir archivos
    - Se necesita una solución portable y sin instalación

    FLUJO DE TRABAJO:
    
    === EN LA MÁQUINA ORIGEN ===
    1. El programa comprime la carpeta origen en un archivo .7z (o .zip si usa compresión nativa)
    2. Divide el archivo comprimido en bloques numerados: .alx0001, .alx0002, .alx0003, etc.
    3. Cada bloque tiene el tamaño especificado (por defecto 10 MB, configurable)
    4. Va solicitando dispositivos USB uno por uno
    5. Copia los bloques secuencialmente en cada USB según espacio disponible
    6. Genera un script INSTALAR.ps1 personalizado con:
       - Ruta de destino recomendada
       - Tipo de compresión usado (7-Zip o ZIP nativo)
       - Lógica de reconstrucción automática
    7. Copia INSTALAR.ps1 en la PRIMERA USB
    8. Marca la ÚLTIMA USB con un archivo __EOF__ (End Of Files)
    
    ALTERNATIVA: GENERACIÓN DE IMÁGENES ISO
    - Si se especifica -Iso, genera imágenes ISO en lugar de copiar a USBs
    - Soporta CD (700MB), DVD (4.5GB) o USB (4.5GB)
    - Si el contenido excede la capacidad del medio, divide en múltiples volúmenes:
      * VOL01.iso, VOL02.iso, VOL03.iso, etc.
      * El instalador está en VOL01
      * El marcador __EOF__ está en el último volumen
    - Misma lógica de distribución que con USBs físicos

    === EN LA MÁQUINA DESTINO ===
    1. Insertar la primera USB (la que tiene INSTALAR.ps1)
    2. Ejecutar .\INSTALAR.ps1 con PowerShell
    3. El instalador busca bloques en el USB actual
    4. Va pidiendo los siguientes USB hasta encontrar __EOF__
    5. Reconstruye el archivo comprimido desde los bloques
    6. Descomprime usando 7-Zip o ZIP nativo según corresponda
    7. Deja la carpeta restaurada en el destino especificado

    MÉTODOS DE COMPRESIÓN:
    
    [7-ZIP] (Recomendado)
    - Busca 7-Zip en: PATH → directorio script → rutas estándar → descarga portable
    - Mejor compresión que ZIP
    - Soporta contraseñas/encriptación
    - Puede crear volúmenes divididos nativamente
    
    [ZIP NATIVO] (Fallback automático o forzado)
    - Usa API de Windows (System.IO.Compression)
    - Requiere Windows 10 o superior
    - NO soporta contraseñas
    - Comprime en un solo archivo y luego lo divide en bloques
    - No requiere software adicional en destino

    LOGS:
    - Solo se generan en caso de error
    - Ubicación: %TEMP%\LLEVAR_ERROR.log (origen) y %TEMP%\INSTALAR_ERROR.log (destino)

.NOTES
    Autor: Basado en LLEVAR.BAT de Alex Soft
    Versión PowerShell modernizada con soporte ZIP nativo
#>

param(
    [string]$Origen,
    [string]$Destino,
    [int]$BlockSizeMB = 10,
    [string]$Clave,
    [pscredential]$SourceCredentials,
    [pscredential]$DestinationCredentials,
    [switch]$Iso,
    [ValidateSet("usb", "cd", "dvd")]
    [string]$IsoDestino = "dvd",
    [switch]$UseNativeZip,
    [switch]$Ejemplo,
    [switch]$Instalar,
    [Alias('h')]
    [switch]$Ayuda,
    [switch]$OnedriveOrigen,
    [switch]$OnedriveDestino,
    [switch]$DropboxOrigen,
    [switch]$DropboxDestino,
    [switch]$RobocopyMirror,
    [switch]$Verbose
)

# ========================================================================== #
#                       IMPORTAR MÓDULOS DEL CORE                            #
# ========================================================================== #

$ModulesPath = Join-Path $PSScriptRoot "Modules"

# Importar módulo de validación primero (necesario para Test-IsRunningInIDE)
Import-Module (Join-Path $ModulesPath "Core\Validation.psm1") -Force -Global

# ========================================================================== #
#                 VERIFICACIÓN DE PERMISOS DE ADMINISTRADOR                  #
# ========================================================================== #

# Verificar si se está ejecutando como administrador
$currentPrincipal = New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())
$isAdmin = $currentPrincipal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)

# Detectar si estamos en VS Code, ISE, u otro IDE usando la función del módulo
$isInIDE = Test-IsRunningInIDE

# Si estamos en IDE, activar verbose automáticamente (sin pasarlo como parámetro)
if ($isInIDE -and -not $Verbose) {
    $Verbose = $true
    Write-Host "[DEBUG/IDE] Verbose activado automáticamente" -ForegroundColor DarkGray
}

# Solo pedir elevación si NO es administrador Y NO está en IDE
$needsElevation = -not $isAdmin -and -not $isInIDE

if ($needsElevation) {
    Write-Host "⚠ Se requieren permisos de administrador para redimensionar la consola." -ForegroundColor Yellow
    Write-Host "Elevando a administrador..." -ForegroundColor Cyan
    
    # Construir argumentos para relanzar el script
    $scriptPath = $MyInvocation.MyCommand.Path
    $arguments = @("-NoExit", "-ExecutionPolicy", "Bypass", "-File", "`"$scriptPath`"")
    
    # Agregar parámetros pasados originalmente
    if ($Origen) { $arguments += "-Origen", "`"$Origen`"" }
    if ($Destino) { $arguments += "-Destino", "`"$Destino`"" }
    if ($BlockSizeMB -ne 10) { $arguments += "-BlockSizeMB", $BlockSizeMB }
    if ($Clave) { $arguments += "-Clave", "`"$Clave`"" }
    if ($Iso) { $arguments += "-Iso" }
    if ($IsoDestino -ne "dvd") { $arguments += "-IsoDestino", $IsoDestino }
    if ($UseNativeZip) { $arguments += "-UseNativeZip" }
    if ($Ejemplo) { $arguments += "-Ejemplo" }
    if ($Ayuda) { $arguments += "-Ayuda" }
    if ($Verbose) { $arguments += "-Verbose" }
    
    # Relanzar con privilegios de administrador
    Start-Process pwsh.exe -Verb RunAs -ArgumentList $arguments
    exit
}
elseif (-not $isAdmin -and $isInIDE) {
    # En IDE no pedimos permisos - continuar normalmente
}

# ========================================================================== #
#                    CONTINUAR IMPORTANDO MÓDULOS                            #
# ========================================================================== #

# Importar módulo de logging
Import-Module (Join-Path $ModulesPath "Core\Logger.psm1") -Force -Global

# Importar módulo de configuración
Import-Module (Join-Path $ModulesPath "Core\Config.psm1") -Force -Global

# Importar módulos UI
Import-Module (Join-Path $ModulesPath "UI\Console.psm1") -Force -Global
Import-Module (Join-Path $ModulesPath "UI\Banners.psm1") -Force -Global
Import-Module (Join-Path $ModulesPath "UI\ProgressBar.psm1") -Force -Global
Import-Module (Join-Path $ModulesPath "UI\Navigator.psm1") -Force -Global
Import-Module (Join-Path $ModulesPath "UI\Menus.psm1") -Force -Global
Import-Module (Join-Path $ModulesPath "UI\Menus.psm1") -Force -Global

# Importar módulos de compresión
Import-Module (Join-Path $ModulesPath "Compression\SevenZip.psm1") -Force -Global
Import-Module (Join-Path $ModulesPath "Compression\NativeZip.psm1") -Force -Global
Import-Module (Join-Path $ModulesPath "Compression\BlockSplitter.psm1") -Force -Global

# Importar módulos de transferencia
Import-Module (Join-Path $ModulesPath "Transfer\Local.psm1") -Force -Global
Import-Module (Join-Path $ModulesPath "Transfer\FTP.psm1") -Force -Global
Import-Module (Join-Path $ModulesPath "Transfer\UNC.psm1") -Force -Global
Import-Module (Join-Path $ModulesPath "Transfer\OneDrive.psm1") -Force -Global
Import-Module (Join-Path $ModulesPath "Transfer\Dropbox.psm1") -Force -Global
Import-Module (Join-Path $ModulesPath "Transfer\Floppy.psm1") -Force -Global
Import-Module (Join-Path $ModulesPath "Transfer\Unified.psm1") -Force -Global

# Importar módulos de instalación
Import-Module (Join-Path $ModulesPath "Installation\SystemInstall.psm1") -Force -Global
Import-Module (Join-Path $ModulesPath "Installation\Installer.psm1") -Force -Global
Import-Module (Join-Path $ModulesPath "Installation\ISO.psm1") -Force -Global

# Importar módulos de utilidades
Import-Module (Join-Path $ModulesPath "Utilities\Installation.psm1") -Force -Global
Import-Module (Join-Path $ModulesPath "Utilities\Examples.psm1") -Force -Global
Import-Module (Join-Path $ModulesPath "Utilities\Help.psm1") -Force -Global
Import-Module (Join-Path $ModulesPath "Utilities\PathSelectors.psm1") -Force -Global
Import-Module (Join-Path $ModulesPath "Utilities\VolumeManagement.psm1") -Force -Global

# Importar módulos del sistema
Import-Module (Join-Path $ModulesPath "System\Audio.psm1") -Force -Global
Import-Module (Join-Path $ModulesPath "System\FileSystem.psm1") -Force -Global
Import-Module (Join-Path $ModulesPath "System\Robocopy.psm1") -Force -Global

# ========================================================================== #
#                            INICIALIZACIÓN DE LOGS                          #
# ========================================================================== #

# Inicializar sistema de logs
Initialize-LogFile -Verbose:$Verbose

# Inicializar consola si es necesario
$hostName = $host.Name -ilike '*consolehost*'
#Write-Host $hostName
#Pause
if ($hostName) {
    $host.UI.RawUI.BackgroundColor = 'Black'
    $host.UI.RawUI.ForegroundColor = 'White'
    Clear-Host
}

# ========================================================================== #

# ========================================================================== #
#                   SISTEMA DE MENÚ INTERACTIVO PRINCIPAL                    #
# ========================================================================== #

function Show-MainMenu {
    <#
    .SYNOPSIS
        Menú principal interactivo de Llevar.ps1
    #>
    
    $config = @{
        # Configuración de Origen
        Origen         = @{
            Tipo           = "Local"  # Local, FTP, OneDrive, Dropbox, UNC, USB
            Path           = $null
            # Solo para FTP
            FtpServer      = $null
            FtpPort        = 21
            FtpDirectory   = "/"
            FtpUser        = $null
            FtpPassword    = $null
            # Solo para UNC/Red
            UncPath        = $null
            UncUser        = $null
            UncPassword    = $null
            UncDomain      = $null
            # Solo para Local/USB
            LocalPath      = $null
            DriveLetter    = $null
            # Solo para OneDrive
            OneDriveEmail  = $null
            OneDriveToken  = $null
            OneDriveApiUrl = "https://graph.microsoft.com/v1.0/me/drive"
            # Solo para Dropbox
            DropboxToken   = $null
            DropboxApiUrl  = "https://api.dropboxapi.com/2"
        }
        
        # Configuración de Destino
        Destino        = @{
            Tipo           = "Local"  # Local, FTP, OneDrive, Dropbox, UNC, USB
            Path           = $null
            # Solo para FTP
            FtpServer      = $null
            FtpPort        = 21
            FtpDirectory   = "/"
            FtpUser        = $null
            FtpPassword    = $null
            # Solo para UNC/Red
            UncPath        = $null
            UncUser        = $null
            UncPassword    = $null
            UncDomain      = $null
            # Solo para Local/USB
            LocalPath      = $null
            DriveLetter    = $null
            # Solo para OneDrive
            OneDriveEmail  = $null
            OneDriveToken  = $null
            OneDriveApiUrl = "https://graph.microsoft.com/v1.0/me/drive"
            # Solo para Dropbox
            DropboxToken   = $null
            DropboxApiUrl  = "https://api.dropboxapi.com/2"
        }
        
        # Configuración general
        BlockSizeMB    = 10
        Clave          = $null
        UseNativeZip   = $false
        Iso            = $false
        IsoDestino     = "dvd"
        RobocopyMirror = $false
    }
    
    while ($true) {
        # Construir display del origen
        $origenDisplay = $config.Origen.Tipo
        if ($config.Origen.Path) {
            $origenDisplay += " → $($config.Origen.Path)"
        }
        elseif ($config.Origen.FtpServer) {
            $origenDisplay += " → $($config.Origen.FtpServer):$($config.Origen.FtpPort)$($config.Origen.FtpDirectory)"
        }
        elseif ($config.Origen.UncPath) {
            $origenDisplay += " → $($config.Origen.UncPath)"
        }
        
        # Construir display del destino
        $destinoDisplay = $config.Destino.Tipo
        if ($config.Destino.Path) {
            $destinoDisplay += " → $($config.Destino.Path)"
        }
        elseif ($config.Destino.FtpServer) {
            $destinoDisplay += " → $($config.Destino.FtpServer):$($config.Destino.FtpPort)$($config.Destino.FtpDirectory)"
        }
        elseif ($config.Destino.UncPath) {
            $destinoDisplay += " → $($config.Destino.UncPath)"
        }
        
        $options = @(
            "*Origen: $origenDisplay",
            "*Destino: $destinoDisplay",
            "*Tamaño de Bloque: $($config.BlockSizeMB) MB",
            "Modo *Robocopy Mirror",
            "Generar *ISO (en lugar de USB)",
            "Usar ZIP *Nativo (sin 7-Zip)",
            "Configurar Con*traseña",
            "Modo *Ejemplo (Demo)",
            "*Ayuda",
            "*Ejecutar Transferencia....LLEVAR =)"
        )
        
        $selection = Show-DosMenu -Title "LLEVAR - MENÚ PRINCIPAL" -Items $options -CancelValue 0
        
        switch ($selection) {
            0 { return $null }  # Salir
            1 { $config = Show-OrigenMenu -Config $config }
            2 { $config = Show-DestinoMenu -Config $config }
            3 { $config = Show-BlockSizeMenu -Config $config }
            4 { $config.RobocopyMirror = -not $config.RobocopyMirror; if ($config.RobocopyMirror) { Show-ConsolePopup -Title "Robocopy Mirror" -Message "Modo Robocopy Mirror activado`n`nSincronizará origen con destino (elimina extras)" -Options @("*OK") | Out-Null } }
            5 { $config = Show-IsoMenu -Config $config }
            6 { $config.UseNativeZip = -not $config.UseNativeZip; Show-ConsolePopup -Title "ZIP Nativo" -Message "ZIP Nativo: $(if($config.UseNativeZip){'ACTIVADO'}else{'DESACTIVADO'})" -Options @("*OK") | Out-Null }
            7 { $config = Show-PasswordMenu -Config $config }
            8 { return @{ Action = "Example" } }
            9 { return @{ Action = "Help" } }
            10 { 
                # Validar configuración completa antes de ejecutar
                $errores = @()
                
                if ($config.RobocopyMirror) {
                    if (-not $config.Origen.Path -and -not $config.Origen.FtpServer -and -not $config.Origen.UncPath) { 
                        $errores += "• Origen no configurado" 
                    }
                    if (-not $config.Destino.Path -and -not $config.Destino.FtpServer -and -not $config.Destino.UncPath) { 
                        $errores += "• Destino no configurado" 
                    }
                }
                else {
                    if (-not $config.Origen.Path -and -not $config.Origen.FtpServer -and -not $config.Origen.UncPath) { 
                        $errores += "• Origen no configurado" 
                    }
                    if (-not $config.Destino.Path -and -not $config.Destino.FtpServer -and -not $config.Destino.UncPath) { 
                        $errores += "• Destino no configurado" 
                    }
                }
                
                if ($errores.Count -gt 0) {
                    $mensaje = "Faltan parámetros requeridos:`n`n" + ($errores -join "`n")
                    Show-ConsolePopup -Title "Configuración Incompleta" -Message $mensaje -Options @("*OK") | Out-Null
                    continue
                }
                
                $config.Action = "Execute"
                return $config
            }
        }
    }
}

function Show-OrigenMenu {
    param($Config)
    
    $options = @(
        "*Local (carpeta del sistema)",
        "*FTP (servidor FTP)",
        "*OneDrive (Microsoft OneDrive)",
        "*Dropbox",
        "*UNC (red compartida)"
    )
    
    $selection = Show-DosMenu -Title "ORIGEN - Seleccione tipo" -Items $options -CancelValue 0
    
    switch ($selection) {
        0 { return $Config }
        1 {
            $Config.Origen.Tipo = "Local"
            $selected = Select-FolderDOS-Llevar "Seleccione carpeta de ORIGEN"
            if ($selected) {
                $Config.Origen.Path = $selected
                $Config.Origen.LocalPath = $selected
                # Limpiar campos FTP/UNC
                $Config.Origen.FtpServer = $null
                $Config.Origen.UncPath = $null
            }
        }
        2 {
            $Config.Origen.Tipo = "FTP"
            $ftpConfig = Get-FtpConfigFromUser -Purpose "ORIGEN"
            if ($ftpConfig) {
                $Config.Origen.Path = $ftpConfig.Path
                $Config.Origen.FtpServer = $ftpConfig.Server
                $Config.Origen.FtpPort = $ftpConfig.Port
                $Config.Origen.FtpDirectory = $ftpConfig.Directory
                $Config.Origen.FtpUser = $ftpConfig.User
                $Config.Origen.FtpPassword = $ftpConfig.Password
                # Limpiar campos Local/UNC
                $Config.Origen.LocalPath = $null
                $Config.Origen.UncPath = $null
            }
        }
        3 {
            $Config.Origen.Tipo = "OneDrive"
            $authResult = Get-OneDriveAuth
            if ($authResult) {
                if ($authResult.UseLocal) {
                    # Uso local
                    $Config.Origen.Path = $authResult.LocalPath
                    $Config.Origen.LocalPath = $authResult.LocalPath
                    $Config.Origen.OneDriveEmail = $authResult.Email
                    $Config.Origen.OneDriveToken = $null
                    $Config.Origen.OneDriveApiUrl = $null
                }
                else {
                    # Uso API
                    Write-Host "`nIngrese la ruta en OneDrive (ej: /Documentos/MiCarpeta):" -ForegroundColor Cyan
                    Write-Host "Presione ENTER para ruta raíz (/)" -ForegroundColor Gray
                    $path = Read-Host "Ruta"
                    if ([string]::IsNullOrWhiteSpace($path)) { $path = "/" }
                    
                    $Config.Origen.Path = "onedrive://$path"
                    $Config.Origen.OneDriveEmail = $authResult.Email
                    $Config.Origen.OneDriveToken = $authResult.Token
                    $Config.Origen.OneDriveApiUrl = $authResult.ApiUrl
                    $Config.Origen.LocalPath = $null
                }
                # Limpiar campos FTP/UNC
                $Config.Origen.FtpServer = $null
                $Config.Origen.UncPath = $null
            }
        }
        4 {
            $Config.Origen.Tipo = "Dropbox"
            $authResult = Get-DropboxAuth
            if ($authResult) {
                if ($authResult.UseLocal) {
                    # Uso local
                    $Config.Origen.Path = $authResult.LocalPath
                    $Config.Origen.LocalPath = $authResult.LocalPath
                    $Config.Origen.DropboxToken = $null
                    $Config.Origen.DropboxApiUrl = $null
                }
                else {
                    # Uso API
                    Write-Host "`nIngrese la ruta en Dropbox (ej: /Documentos/MiCarpeta):" -ForegroundColor Cyan
                    Write-Host "Presione ENTER para ruta raíz (/)" -ForegroundColor Gray
                    $path = Read-Host "Ruta"
                    if ([string]::IsNullOrWhiteSpace($path)) { $path = "/" }
                    
                    $Config.Origen.Path = "dropbox://$path"
                    $Config.Origen.DropboxToken = $authResult.Token
                    $Config.Origen.DropboxApiUrl = $authResult.ApiUrl
                    $Config.Origen.LocalPath = $null
                }
                # Limpiar campos FTP/UNC
                $Config.Origen.FtpServer = $null
                $Config.Origen.UncPath = $null
            }
        }
        5 {
            $Config.Origen.Tipo = "UNC"
            $uncResult = Select-NetworkPath -Purpose "ORIGEN"
            
            if ($uncResult) {
                $Config.Origen.Path = $uncResult.Path
                $Config.Origen.UncPath = $uncResult.Path
                if ($uncResult.Credentials) {
                    $Config.Origen.UncUser = $uncResult.Credentials.UserName
                    $Config.Origen.UncPassword = $uncResult.Credentials.GetNetworkCredential().Password
                    $Config.Origen.UncDomain = $uncResult.Credentials.GetNetworkCredential().Domain
                }
                # Limpiar campos FTP/Local
                $Config.Origen.FtpServer = $null
                $Config.Origen.LocalPath = $null
            }
        }
    }
    
    return $Config
}

function Show-DestinoMenu {
    param($Config)
    
    $options = @(
        "*Local (carpeta del sistema)",
        "*USB (copiar a dispositivos USB)",
        "*Diskettes (disquetes 1.44MB)",
        "*FTP (servidor FTP)",
        "*OneDrive (Microsoft OneDrive)",
        "*Dropbox",
        "U*NC (red compartida)"
    )
    
    $selection = Show-DosMenu -Title "DESTINO - Seleccione tipo" -Items $options -CancelValue 0
    
    switch ($selection) {
        0 { return $Config }
        1 {
            $Config.Destino.Tipo = "Local"
            $selected = Select-FolderDOS-Llevar "Seleccione carpeta de DESTINO"
            if ($selected) {
                $Config.Destino.Path = $selected
                $Config.Destino.LocalPath = $selected
                # Limpiar campos FTP/UNC
                $Config.Destino.FtpServer = $null
                $Config.Destino.UncPath = $null
            }
        }
        2 {
            $Config.Destino.Tipo = "USB"
            Show-ConsolePopup -Title "Modo USB" -Message "El programa solicitará USBs durante la transferencia" -Options @("*OK") | Out-Null
            $Config.Destino.Path = "USB"
            # Limpiar campos FTP/UNC/Local
            $Config.Destino.FtpServer = $null
            $Config.Destino.UncPath = $null
            $Config.Destino.LocalPath = $null
        }
        3 {
            $Config.Destino.Tipo = "Floppy"
            
            # Verificar si hay unidad de diskette
            if (-not (Test-FloppyDriveAvailable)) {
                Show-ConsolePopup -Title "Error" -Message "No se detectó una unidad de diskette (A:) en el sistema.`n`nLos diskettes son tecnología obsoleta. Se recomienda usar USB o ISO." -Options @("*OK") | Out-Null
                return $Config
            }
            
            $mensaje = @"
⚠ MODO DISKETTES (LEGACY)

Los diskettes de 1.44MB son medios obsoletos y poco confiables.
Este modo existe solo por compatibilidad histórica.

Características:
• Capacidad: 1.44 MB por diskette
• Máximo: 30 diskettes
• Formateo automático
• Verificación de integridad

¿Desea continuar con diskettes?
"@
            
            $confirmOptions = @("*Sí, usar diskettes", "*No, elegir otro destino")
            $confirm = Show-ConsolePopup -Title "Confirmación" -Message $mensaje -Options $confirmOptions
            
            if ($confirm -eq 1) {
                $Config.Destino.Path = "FLOPPY"
                Show-ConsolePopup -Title "Modo Diskette" -Message "El programa solicitará diskettes durante la transferencia.`nAsegúrese de tener suficientes diskettes vacíos." -Options @("*OK") | Out-Null
                # Limpiar otros campos
                $Config.Destino.FtpServer = $null
                $Config.Destino.UncPath = $null
                $Config.Destino.LocalPath = $null
            }
        }
        4 {
            $Config.Destino.Tipo = "FTP"
            $ftpConfig = Get-FtpConfigFromUser -Purpose "DESTINO"
            if ($ftpConfig) {
                $Config.Destino.Path = $ftpConfig.Path
                $Config.Destino.FtpServer = $ftpConfig.Server
                $Config.Destino.FtpPort = $ftpConfig.Port
                $Config.Destino.FtpDirectory = $ftpConfig.Directory
                $Config.Destino.FtpUser = $ftpConfig.User
                $Config.Destino.FtpPassword = $ftpConfig.Password
                # Limpiar campos Local/UNC
                $Config.Destino.LocalPath = $null
                $Config.Destino.UncPath = $null
            }
        }
        5 {
            $Config.Destino.Tipo = "OneDrive"
            $authResult = Get-OneDriveAuth
            if ($authResult) {
                if ($authResult.UseLocal) {
                    # Uso local
                    $Config.Destino.Path = $authResult.LocalPath
                    $Config.Destino.LocalPath = $authResult.LocalPath
                    $Config.Destino.OneDriveEmail = $authResult.Email
                    $Config.Destino.OneDriveToken = $null
                    $Config.Destino.OneDriveApiUrl = $null
                }
                else {
                    # Uso API
                    Write-Host "`nIngrese la ruta en OneDrive (ej: /Backups/MiCarpeta):" -ForegroundColor Cyan
                    Write-Host "Presione ENTER para ruta raíz (/)" -ForegroundColor Gray
                    $path = Read-Host "Ruta"
                    if ([string]::IsNullOrWhiteSpace($path)) { $path = "/" }
                    
                    $Config.Destino.Path = "onedrive://$path"
                    $Config.Destino.OneDriveEmail = $authResult.Email
                    $Config.Destino.OneDriveToken = $authResult.Token
                    $Config.Destino.OneDriveApiUrl = $authResult.ApiUrl
                    $Config.Destino.LocalPath = $null
                }
                # Limpiar campos FTP/UNC
                $Config.Destino.FtpServer = $null
                $Config.Destino.UncPath = $null
            }
        }
        6 {
            $Config.Destino.Tipo = "Dropbox"
            $authResult = Get-DropboxAuth
            if ($authResult) {
                if ($authResult.UseLocal) {
                    # Uso local
                    $Config.Destino.Path = $authResult.LocalPath
                    $Config.Destino.LocalPath = $authResult.LocalPath
                    $Config.Destino.DropboxToken = $null
                    $Config.Destino.DropboxApiUrl = $null
                }
                else {
                    # Uso API
                    Write-Host "`nIngrese la ruta en Dropbox (ej: /Backups/MiCarpeta):" -ForegroundColor Cyan
                    Write-Host "Presione ENTER para ruta raíz (/)" -ForegroundColor Gray
                    $path = Read-Host "Ruta"
                    if ([string]::IsNullOrWhiteSpace($path)) { $path = "/" }
                    
                    $Config.Destino.Path = "dropbox://$path"
                    $Config.Destino.DropboxToken = $authResult.Token
                    $Config.Destino.DropboxApiUrl = $authResult.ApiUrl
                    $Config.Destino.LocalPath = $null
                }
                # Limpiar campos FTP/UNC
                $Config.Destino.FtpServer = $null
                $Config.Destino.UncPath = $null
            }
        }
        7 {
            $Config.Destino.Tipo = "UNC"
            $uncResult = Select-NetworkPath -Purpose "DESTINO"
            
            if ($uncResult) {
                $Config.Destino.Path = $uncResult.Path
                $Config.Destino.UncPath = $uncResult.Path
                if ($uncResult.Credentials) {
                    $Config.Destino.UncUser = $uncResult.Credentials.UserName
                    $Config.Destino.UncPassword = $uncResult.Credentials.GetNetworkCredential().Password
                    $Config.Destino.UncDomain = $uncResult.Credentials.GetNetworkCredential().Domain
                }
                # Limpiar campos FTP/Local
                $Config.Destino.FtpServer = $null
                $Config.Destino.LocalPath = $null
            }
        }
    }
    
    return $Config
}

function Show-BlockSizeMenu {
    param($Config)
    
    Write-Host ""
    Write-Host "Tamaño actual de bloque: $($Config.BlockSizeMB) MB" -ForegroundColor Cyan
    Write-Host ""
    Write-Host "Tamaños comunes:" -ForegroundColor Gray
    Write-Host "  • 10 MB  - USBs pequeños" -ForegroundColor DarkGray
    Write-Host "  • 50 MB  - USBs medianos" -ForegroundColor DarkGray
    Write-Host "  • 100 MB - USBs grandes" -ForegroundColor DarkGray
    Write-Host "  • 500 MB - Discos externos" -ForegroundColor DarkGray
    Write-Host ""
    Write-Host "Ingrese nuevo tamaño en MB (ENTER para mantener actual): " -NoNewline -ForegroundColor Cyan
    $userInput = Read-Host
    
    if (-not [string]::IsNullOrWhiteSpace($userInput)) {
        $newSize = 0
        if ([int]::TryParse($userInput, [ref]$newSize) -and $newSize -gt 0) {
            $Config.BlockSizeMB = $newSize
            Show-ConsolePopup -Title "Tamaño de Bloque" -Message "Tamaño configurado: $newSize MB" -Options @("*OK") | Out-Null
        }
        else {
            Show-ConsolePopup -Title "Error" -Message "Tamaño inválido. Debe ser un número mayor a 0" -Options @("*OK") | Out-Null
        }
    }
    
    return $Config
}

function Show-PasswordMenu {
    param($Config)
    
    if ($Config.Clave) {
        $options = @(
            "*Cambiar contraseña",
            "*Eliminar contraseña"
        )
        $selection = Show-DosMenu -Title "CONTRASEÑA (Actual: ******)" -Items $options -CancelValue 0
        
        if ($selection -eq 0) { return $Config }
        if ($selection -eq 2) {
            $Config.Clave = $null
            Show-ConsolePopup -Title "Contraseña" -Message "Contraseña eliminada" -Options @("*OK") | Out-Null
            return $Config
        }
    }
    
    Show-Banner "CONFIGURAR CONTRASEÑA" -BorderColor Cyan -TextColor Yellow
    Write-Host "⚠ NOTA: Solo funciona con 7-Zip (no con ZIP nativo)" -ForegroundColor Yellow
    Write-Host ""
    Write-Host "Ingrese contraseña (ENTER para cancelar): " -NoNewline -ForegroundColor Cyan
    $pass1 = Read-Host -AsSecureString
    
    if ($pass1.Length -eq 0) {
        return $Config
    }
    
    Write-Host "Confirme contraseña: " -NoNewline -ForegroundColor Cyan
    $pass2 = Read-Host -AsSecureString
    
    $ptr1 = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($pass1)
    $ptr2 = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($pass2)
    $plainPass1 = [System.Runtime.InteropServices.Marshal]::PtrToStringBSTR($ptr1)
    $plainPass2 = [System.Runtime.InteropServices.Marshal]::PtrToStringBSTR($ptr2)
    [System.Runtime.InteropServices.Marshal]::ZeroFreeBSTR($ptr1)
    [System.Runtime.InteropServices.Marshal]::ZeroFreeBSTR($ptr2)
    
    if ($plainPass1 -eq $plainPass2) {
        $Config.Clave = $plainPass1
        Show-ConsolePopup -Title "Contraseña" -Message "Contraseña configurada correctamente" -Options @("*OK") | Out-Null
    }
    else {
        Show-ConsolePopup -Title "Error" -Message "Las contraseñas no coinciden" -Options @("*OK") | Out-Null
    }
    
    return $Config
}

# ========================================================================== #
# ========================================================================== #
#                          FLUJO PRINCIPAL (LLEVAR)                          #
# ========================================================================== #

# Mostrar logo ASCII si existe (siempre)
$logoPath = Join-Path $PSScriptRoot "alexsoft.txt"
if (Test-Path $logoPath) {
    # Usar Show-AsciiLogo como renderer unificado para el logo con sonidos estilo DOS    
    Show-AsciiLogo -Path $logoPath -DelayMs 30 -ShowProgress $true -Label "Cargando..." -ForegroundColor Gray -PlaySound $true
    # Limpiar pantalla después de cargar el logo
    Clear-Host
    
    # Mostrar mensaje de bienvenida personalizado parpadeante
    Show-WelcomeMessage -BlinkCount 3 -VisibleDelayMs 450 -TextColor Cyan
    
    # Limpiar para mostrar el menú
    Clear-Host
}

# ========================================================================== #
#                        VERIFICACIÓN DE INSTALACIÓN                         #
# ========================================================================== #

# Verificar si NO está ejecutándose desde C:\Llevar (excepto si es -Ejemplo o -Ayuda)
if (-not $Ejemplo -and -not $Ayuda) {
    $isInstalled = Test-LlevarInstallation
    
    if (-not $isInstalled) {
        $wantsInstall = Show-InstallationPrompt
        
        if ($wantsInstall) {
            # Usuario dijo SÍ - proceder con instalación
            # Reutilizar las variables de permisos ya definidas al inicio (líneas 130-135)
            
            if ($isInIDE) {
                Write-Host "`n[DEBUG/IDE] Omitiendo verificación de permisos de administrador" -ForegroundColor Cyan
                
                # Instalar directamente sin verificar permisos
                $installed = Install-LlevarToSystem
                
                if ($installed) {
                    Write-Host "`nPresione cualquier tecla para continuar con la ejecución normal..." -ForegroundColor Gray
                    $null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')
                    Clear-Host
                }
                else {
                    Write-Host "`nNo se pudo completar la instalación." -ForegroundColor Red
                    Write-Host "Presione cualquier tecla para salir..." -ForegroundColor Gray
                    $null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')
                    exit
                }
            }
            else {
                # Reutilizar verificación de permisos ya realizada al inicio
                if (-not $isAdmin) {
                    Write-Host "`n⚠ Se requieren permisos de administrador para instalar." -ForegroundColor Yellow
                    Write-Host "Relanzando como administrador..." -ForegroundColor Cyan
                
                    $scriptPath = $MyInvocation.MyCommand.Path
                    Start-Process powershell.exe -ArgumentList "-NoExit", "-ExecutionPolicy", "Bypass", "-File", "`"$scriptPath`"" -Verb RunAs
                    exit
                }
                else {
                    # Ya es admin, instalar directamente
                    $installed = Install-LlevarToSystem
                
                    if ($installed) {
                        Write-Host "`nPresione cualquier tecla para continuar con la ejecución normal..." -ForegroundColor Gray
                        $null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')
                        Clear-Host
                    }
                    else {
                        Write-Host "`nNo se pudo completar la instalación." -ForegroundColor Red
                        Write-Host "Presione cualquier tecla para salir..." -ForegroundColor Gray
                        $null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')
                        exit
                    }
                }
            }
        }
        # Si wantsInstall es FALSE, simplemente continuar sin hacer nada
        # El script seguirá ejecutándose normalmente desde su ubicación actual
    }
    # Si isInstalled es TRUE, simplemente continuar sin mostrar nada
}

# ========================================================================== #
#                     MENU INTERACTIVO (sin parámetros)                      #
# ========================================================================== #

# Detectar si se ejecutó sin parámetros principales
$noParams = (
    -not $Ayuda -and
    -not $Instalar -and
    -not $RobocopyMirror -and
    -not $Ejemplo -and
    -not $Origen -and
    -not $Destino -and
    -not $Iso
)

if ($noParams) {
    Show-Banner "MODO INTERACTIVO" -BorderColor Cyan -TextColor Cyan
    Write-Host "No se especificaron parámetros. Iniciando menú interactivo..." -ForegroundColor Gray
    Write-Host ""
    
    # Mostrar menú principal
    $config = Show-MainMenu
    
    # Si el usuario canceló (salió del menú), terminar
    if ($null -eq $config -or $config.Action -eq "Exit") {
        Write-Host ""
        Write-Host "Operación cancelada por el usuario." -ForegroundColor Yellow
        Write-Host ""
        exit
    }
    
    # Reutilizar las variables de permisos definidas al inicio
    # ya tenemos: $isAdmin, $isInIDE (líneas 130-135)
    
    # Procesar configuración del menú según la acción seleccionada
    switch ($config.Action) {
        "Execute" {
            # Mapear configuración del menú a variables del script
            
            # Mapear origen según su tipo
            if ($config.Origen.FtpServer) {
                # Es FTP - construir URL y credenciales
                $Origen = $config.Origen.Path
                $script:FtpSourceServer = $config.Origen.FtpServer
                $script:FtpSourcePort = $config.Origen.FtpPort
                $script:FtpSourceUser = $config.Origen.FtpUser
                $script:FtpSourcePassword = $config.Origen.FtpPassword
            }
            elseif ($config.Origen.UncPath) {
                # Es UNC - ruta y credenciales de red
                $Origen = $config.Origen.Path
                if ($config.Origen.UncUser) {
                    $secPassword = ConvertTo-SecureString $config.Origen.UncPassword -AsPlainText -Force
                    $script:UncSourceCredentials = New-Object System.Management.Automation.PSCredential($config.Origen.UncUser, $secPassword)
                }
            }
            else {
                # Es Local, OneDrive, Dropbox o USB
                $Origen = $config.Origen.Path
            }
            
            # Mapear destino según su tipo
            if ($config.Destino.FtpServer) {
                # Es FTP - construir URL y credenciales
                $Destino = $config.Destino.Path
                $script:FtpDestinationServer = $config.Destino.FtpServer
                $script:FtpDestinationPort = $config.Destino.FtpPort
                $script:FtpDestinationUser = $config.Destino.FtpUser
                $script:FtpDestinationPassword = $config.Destino.FtpPassword
            }
            elseif ($config.Destino.UncPath) {
                # Es UNC - ruta y credenciales de red
                $Destino = $config.Destino.Path
                if ($config.Destino.UncUser) {
                    $secPassword = ConvertTo-SecureString $config.Destino.UncPassword -AsPlainText -Force
                    $script:UncDestinationCredentials = New-Object System.Management.Automation.PSCredential($config.Destino.UncUser, $secPassword)
                }
            }
            else {
                # Es Local, OneDrive, Dropbox o USB
                $Destino = $config.Destino.Path
            }
            
            # Mapear configuración general
            $BlockSizeMB = $config.BlockSizeMB
            $Clave = $config.Clave
            $UseNativeZip = $config.UseNativeZip
            $Iso = $config.Iso
            $IsoDestino = $config.IsoDestino
            $RobocopyMirror = $config.RobocopyMirror
            
            Show-Banner "CONFIGURACIÓN COMPLETA - INICIANDO EJECUCIÓN" -BorderColor Green -TextColor Green
            
            # Log verbose de la configuración
            if ($Global:VerboseLogging) {
                Write-Log "=== CONFIGURACIÓN MAPEADA ===" "DEBUG"
                Write-Log "Origen: $Origen (Tipo: $($config.Origen.Tipo))" "DEBUG"
                Write-Log "Destino: $Destino (Tipo: $($config.Destino.Tipo))" "DEBUG"
                if ($config.Origen.FtpServer) {
                    Write-Log "FTP Origen: $($config.Origen.FtpServer):$($config.Origen.FtpPort) Usuario: $($config.Origen.FtpUser)" "DEBUG"
                }
                if ($config.Destino.FtpServer) {
                    Write-Log "FTP Destino: $($config.Destino.FtpServer):$($config.Destino.FtpPort) Usuario: $($config.Destino.FtpUser)" "DEBUG"
                }
            }
        }
        "Example" {
            # Activar modo ejemplo
            $Ejemplo = $true
        }
        "Help" {
            # Mostrar ayuda
            Clear-Host
            Show-Help
            exit
        }
    }
}

# Si es ayuda, mostrarla
if ($Ayuda) {
    Clear-Host
    Show-Help
    exit
}

# Modo Robocopy Mirror
if ($RobocopyMirror) {
    # Solicitar origen y destino usando la función centralizada
    $Origen = Get-PathOrPrompt $Origen "ORIGEN"
    $Destino = Get-PathOrPrompt $Destino "DESTINO"
    
    # Ejecutar copia espejo
    Invoke-RobocopyMirror -Origen $Origen -Destino $Destino
    
    Write-Host ""
    Write-Host "Presione cualquier tecla para salir..." -ForegroundColor Gray
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    exit
}

# Modo Ejemplo
if ($Ejemplo) {
    try {
        $ejemploConfig = Invoke-ExampleMode
        
        $Origen = $ejemploConfig.Origen
        $Destino = $ejemploConfig.Destino
        $directoriosLimpiar = $ejemploConfig.DirectoriosLimpiar
        
        # Validar si se forzó ZIP nativo
        if ($UseNativeZip) {
            if (-not (Test-Windows10OrLater)) {
                Write-Host ""
                Write-Host "ERROR: La compresión ZIP nativa requiere Windows 10 o superior." -ForegroundColor Red
                Write-Host ""
                return
            }
            $SevenZ = "NATIVE_ZIP"
        }
        else {
            $SevenZ = Get-7z-Llevar
        }
        
        $Temp = Join-Path $env:TEMP "LLEVAR_TEMP_EJEMPLO"
        if (-not (Test-Path $Temp)) { New-Item -Type Directory $Temp | Out-Null }
        
        # Validar destino escribible
        if (-not (Test-PathWritable -Path $Destino)) {
            Write-Host "Destino no es escribible. Cancelando." -ForegroundColor Red
            Remove-ExampleData -Directories $directoriosLimpiar -TempDir $Temp
            return
        }
        
        # Ejecutar compresión
        $compressionResult = Compress-Folder $Origen $Temp $SevenZ $Clave $BlockSizeMB
        $blocks = $compressionResult.Files
        $compressionType = $compressionResult.CompressionType
        
        Show-Banner -Message "BLOQUES GENERADOS" -BorderColor Cyan -TextColor Cyan
        Write-Host "Total de bloques: $($blocks.Count)" -ForegroundColor White
        Write-Host "Tipo de compresión: $compressionType" -ForegroundColor White
        Write-Host ""
        
        $totalSize = 0
        foreach ($block in $blocks) {
            $size = (Get-Item $block).Length
            $totalSize += $size
            Write-Host "  • $([System.IO.Path]::GetFileName($block)) - $('{0:N2}' -f ($size / 1MB)) MB" -ForegroundColor Gray
        }
        Write-Host ""
        Write-Host "Tamaño total: $('{0:N2}' -f ($totalSize / 1MB)) MB" -ForegroundColor White
        Write-Host ""
        
        # Copiar bloques al destino
        Show-Banner "COPIANDO BLOQUES AL DESTINO" -BorderColor Cyan -TextColor Cyan
        
        $installerScript = New-InstallerScript -Destino $Destino -Temp $Temp -CompressionType $compressionType
        
        # Copiar cada bloque al destino
        $counter = 0
        foreach ($block in $blocks) {
            $counter++
            $fileName = [System.IO.Path]::GetFileName($block)
            $destPath = Join-Path $Destino $fileName
            
            Write-Host "[$counter/$($blocks.Count)] Copiando: $fileName" -ForegroundColor Gray
            Copy-Item $block $destPath -Force
            Write-Host "  ✓ Copiado" -ForegroundColor Green
        }
        
        # Copiar instalador
        if ($installerScript) {
            Write-Host ""
            Write-Host "Copiando INSTALAR.ps1 al destino..." -ForegroundColor Gray
            Copy-Item $installerScript $Destino -Force
            Write-Host "  ✓ Copiado" -ForegroundColor Green
        }
        
        # Copiar 7z si es necesario
        if ($SevenZ -ne "NATIVE_ZIP" -and (Test-Path $SevenZ)) {
            Write-Host "Copiando 7z.exe al destino..." -ForegroundColor Gray
            Copy-Item $SevenZ $Destino -Force
            Write-Host "  ✓ Copiado" -ForegroundColor Green
        }
        
        # Crear marcador EOF
        Write-Host "Creando marcador __EOF__..." -ForegroundColor Gray
        New-Item -ItemType File -Path (Join-Path $Destino "__EOF__") -Force | Out-Null
        Write-Host "  ✓ Creado" -ForegroundColor Green
        
        Show-Banner "PROCESO COMPLETADO" -BorderColor Cyan -TextColor Cyan
        Write-Host "✓ Bloques copiados al destino: $Destino" -ForegroundColor Green
        Write-Host "✓ Total de archivos en destino: $($blocks.Count + 3)" -ForegroundColor Green
        Write-Host ""
        
        # Limpieza
        Remove-ExampleData -Directories $directoriosLimpiar -TempDir $Temp
        
        Show-Banner "EJEMPLO FINALIZADO" -BorderColor Cyan -TextColor Cyan
        Write-Host "Para instalar en otra máquina, copie el contenido de:" -ForegroundColor Yellow
        Write-Host "  $Destino" -ForegroundColor White
        Write-Host ""
        Write-Host "Y ejecute: .\INSTALAR.ps1" -ForegroundColor Yellow
        Write-Host ""
        
        return
    }
    catch {
        Write-ErrorLog "Error en modo ejemplo." $_
        Write-Host ""
        Write-Host "✗ Error en modo ejemplo: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "Revise el log en: $Global:LogFile" -ForegroundColor Yellow
        Write-Host ""
        
        if ($directoriosLimpiar) {
            Remove-ExampleData -Directories $directoriosLimpiar -TempDir $Temp
        }
        return
    }
}

# ========================================================================== #
#                VERIFICAR INSTALACIÓN Y PARÁMETRO -Instalar                 #
# ========================================================================== #

# Si se pasó -Instalar, realizar instalación directamente
if ($Instalar) {
    # Reutilizar las variables de permisos ya definidas al inicio
    # ya tenemos: $isAdmin, $isInIDE (líneas 130-135)
    
    if ($isInIDE) {
        Write-Host "`n[DEBUG/IDE] Omitiendo verificación de permisos de administrador" -ForegroundColor Cyan
    }
    else {
        # Usar verificación ya realizada al inicio
        if (-not $isAdmin) {
            Write-Host "`n⚠ Se requieren permisos de administrador para instalar." -ForegroundColor Yellow
            Write-Host "Elevando a administrador..." -ForegroundColor Cyan
            
            $scriptPath = $MyInvocation.MyCommand.Path
            Start-Process powershell.exe -ArgumentList "-NoExit", "-ExecutionPolicy", "Bypass", "-File", "`"$scriptPath`"", "-Instalar" -Verb RunAs
            exit
        }
    }
    
    # Realizar instalación
    $installed = Install-LlevarToSystem
    
    if ($installed) {
        Write-Host "Presione cualquier tecla para salir..." -ForegroundColor Gray
        $null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')
    }
    
    exit
}

# ========================================================================== #
#                     MODO NORMAL - EJECUCIÓN PRINCIPAL                      #
# ========================================================================== #

# Modo Normal
try {
    # Validar si se forzó ZIP nativo
    if ($UseNativeZip) {
        if (-not (Test-Windows10OrLater)) {
            Write-Host ""
            Write-Host "ERROR: La compresión ZIP nativa requiere Windows 10 o superior." -ForegroundColor Red
            Write-Host ""
            Write-Host "Su versión de Windows: $([System.Environment]::OSVersion.Version)" -ForegroundColor Yellow
            Write-Host ""
            Write-Host "Opciones:" -ForegroundColor Cyan
            Write-Host "  1. Actualice a Windows 10 o superior" -ForegroundColor Gray
            Write-Host "  2. Quite el parámetro -UseNativeZip para usar 7-Zip automáticamente" -ForegroundColor Gray
            Write-Host "  3. Instale 7-Zip manualmente desde: https://www.7-zip.org/" -ForegroundColor Gray
            Write-Host ""
            return
        }
        Write-Host ""
        Write-Host "Usando compresión ZIP nativa de Windows (forzado por parámetro)" -ForegroundColor Cyan
        Write-Host "NOTA: ZIP nativo NO soporta contraseñas. El parámetro -Clave será ignorado." -ForegroundColor Yellow
        Write-Host ""
    }

    # Validar origen si viene del menú contextual
    if ($Origen) {
        # Si el origen viene del menú contextual, validarlo
        if (Test-Path $Origen) {
            Show-Banner "ORIGEN PRESELECCIONADO DESDE MENÚ CONTEXTUAL" -BorderColor Cyan -TextColor Cyan
            
            $item = Get-Item $Origen
            if ($item.PSIsContainer) {
                Write-Host "Carpeta seleccionada: $Origen" -ForegroundColor Green
            }
            else {
                Write-Host "Archivo seleccionado: $Origen" -ForegroundColor Green
                Write-Host ""
                Write-Host "NOTA: Se comprimirá el archivo individual." -ForegroundColor Yellow
            }
            Write-Host ""
        }
        else {
            Write-Host ""
            Write-Host "⚠ El origen especificado no existe: $Origen" -ForegroundColor Yellow
            Write-Host ""
            $Origen = $null
        }
    }
    
    # Si no hay origen o era inválido, pedirlo
    if (-not $Origen) {
        $Origen = Get-PathOrPrompt $Origen "ORIGEN"
    }
    
    # Pedir destino solo si no está configurado o es una ruta local que no existe
    if (-not $Destino) {
        $Destino = Get-PathOrPrompt $Destino "DESTINO"
    }
    elseif (-not ($Destino -match '^ftp://|^onedrive://|^dropbox://|^\\\\')) {
        # Si es ruta local, verificar que exista
        if (-not (Test-Path $Destino)) {
            Write-Host ""
            Write-Host "⚠ El destino especificado no existe: $Destino" -ForegroundColor Yellow
            Write-Host ""
            $Destino = Get-PathOrPrompt $Destino "DESTINO"
        }
    }

    # Determinar si origen o destino son FTP, OneDrive o Dropbox
    $origenEsFtp = Test-IsFtpPath -Path $Origen
    $destinoEsFtp = Test-IsFtpPath -Path $Destino
    $origenEsOneDrive = $OnedriveOrigen -or (Test-IsOneDrivePath -Path $Origen)
    $destinoEsOneDrive = $OnedriveDestino -or (Test-IsOneDrivePath -Path $Destino)
    $origenEsDropbox = $DropboxOrigen -or (Test-IsDropboxPath -Path $Origen)
    $destinoEsDropbox = $DropboxDestino -or (Test-IsDropboxPath -Path $Destino)
    
    # Si alguno es FTP, OneDrive o Dropbox, preguntar modo de transferencia
    $TransferMode = "Compress" # Por defecto comprimir
    if ($origenEsFtp -or $destinoEsFtp -or $origenEsOneDrive -or $destinoEsOneDrive -or $origenEsDropbox -or $destinoEsDropbox) {
        $tipoTransfer = "FTP"
        if ($origenEsOneDrive -or $destinoEsOneDrive) { $tipoTransfer = "OneDrive/FTP" }
        if ($origenEsDropbox -or $destinoEsDropbox) { $tipoTransfer = "Dropbox/OneDrive/FTP" }
        
        $mensaje = @"
¿Cómo desea realizar la transferencia?

• Transferir Directamente: Copia archivos sin comprimir
• Comprimir Primero: Comprime, divide en bloques y transfiere (genera INSTALAR.ps1)

Nota: Si elige comprimir, los archivos temporales se eliminarán automáticamente.
"@
        
        $opciones = @("*Transferir Directamente", "*Comprimir Primero")
        $seleccion = Show-ConsolePopup -Title "Modo de Transferencia $tipoTransfer" -Message $mensaje -Options $opciones -DefaultValue 2
        
        $TransferMode = if ($seleccion -eq 1) { "Direct" } else { "Compress" }
        Write-Host "Modo seleccionado: $TransferMode" -ForegroundColor Cyan
    }
    
    # Autenticar con OneDrive si es necesario
    if ($origenEsOneDrive -or $destinoEsOneDrive) {
        # Primero verificar que los módulos de Microsoft.Graph estén instalados
        if (-not (Test-MicrosoftGraphModule)) {
            Write-Host ""
            Write-Host "✗ No se pueden usar funciones de OneDrive sin los módulos Microsoft.Graph" -ForegroundColor Red
            Write-Host ""
            return
        }
        
        Show-Banner "AUTENTICACIÓN ONEDRIVE" -BorderColor Cyan -TextColor Yellow
        
        if (-not (Connect-GraphSession)) {
            Write-Host "No se pudo autenticar con OneDrive. Cancelando." -ForegroundColor Red
            return
        }
    }
    
    # Autenticar con Dropbox si es necesario
    if ($origenEsDropbox -or $destinoEsDropbox) {
        Show-Banner "AUTENTICACIÓN DROPBOX" -BorderColor Cyan -TextColor Yellow
        
        if (-not (Connect-DropboxSession)) {
            Write-Host "No se pudo autenticar con Dropbox. Cancelando." -ForegroundColor Red
            return
        }
    }

    # Si Origen o Destino son rutas UNC, FTP, OneDrive o Dropbox, procesarlas
    $origenMontado = $Origen
    $destinoMontado = $Destino
    $origenDrive = $null
    $destinoDrive = $null
    
    # Manejar origen OneDrive
    if ($origenEsOneDrive) {
        Write-Host "Configurando origen OneDrive..." -ForegroundColor Cyan
        if ($Origen -match '^onedrive://(.+)$' -or $Origen -match '^ONEDRIVE:(.+)$') {
            $origenMontado = $Matches[1]
        }
        else {
            # Solicitar ruta en OneDrive
            Write-Host "Ingrese la ruta en OneDrive (ejemplo: /Documentos/MiCarpeta): " -NoNewline
            $origenMontado = Read-Host
        }
        Write-Host "✓ Origen OneDrive configurado: $origenMontado" -ForegroundColor Green
    }
    # Manejar origen Dropbox
    elseif ($origenEsDropbox) {
        Write-Host "Configurando origen Dropbox..." -ForegroundColor Cyan
        if ($Origen -match '^dropbox://(.+)$' -or $Origen -match '^DROPBOX:(.+)$') {
            $origenMontado = $Matches[1]
        }
        else {
            # Solicitar ruta en Dropbox
            Write-Host "Ingrese la ruta en Dropbox (ejemplo: /Documentos/MiCarpeta): " -NoNewline
            $origenMontado = Read-Host
        }
        Write-Host "✓ Origen Dropbox configurado: $origenMontado" -ForegroundColor Green
    }
    elseif ($Origen -match '^\\\\' -or (Test-IsFtpPath -Path $Origen)) {
        $origenEsFtp = Test-IsFtpPath -Path $Origen
        $tipoOrigen = if ($origenEsFtp) { "FTP" } else { "UNC" }
        Write-Host "Montando ruta $tipoOrigen de origen..." -ForegroundColor Cyan
        $origenDrive = "LLEVAR_ORIGEN"
        try {
            $credOrigen = if ($origenEsFtp) { $SourceCredentials } else { $null }
            $origenMontado = Mount-LlevarNetworkPath -Path $Origen -Credential $credOrigen -DriveName $origenDrive
            Write-Host "✓ Origen montado: $origenMontado" -ForegroundColor Green
        }
        catch {
            Write-Host "Error al montar origen: $($_.Exception.Message)" -ForegroundColor Red
            return
        }
    }
    
    # Manejar destino OneDrive
    if ($destinoEsOneDrive) {
        Write-Host "Configurando destino OneDrive..." -ForegroundColor Cyan
        if ($Destino -match '^onedrive://(.+)$' -or $Destino -match '^ONEDRIVE:(.+)$') {
            $destinoMontado = $Matches[1]
        }
        else {
            # Solicitar ruta en OneDrive
            Write-Host "Ingrese la ruta en OneDrive (ejemplo: /Documentos/Destino): " -NoNewline
            $destinoMontado = Read-Host
        }
        Write-Host "✓ Destino OneDrive configurado: $destinoMontado" -ForegroundColor Green
    }
    # Manejar destino Dropbox
    elseif ($destinoEsDropbox) {
        Write-Host "Configurando destino Dropbox..." -ForegroundColor Cyan
        if ($Destino -match '^dropbox://(.+)$' -or $Destino -match '^DROPBOX:(.+)$') {
            $destinoMontado = $Matches[1]
        }
        else {
            # Solicitar ruta en Dropbox
            Write-Host "Ingrese la ruta en Dropbox (ejemplo: /Documentos/Destino): " -NoNewline
            $destinoMontado = Read-Host
        }
        Write-Host "✓ Destino Dropbox configurado: $destinoMontado" -ForegroundColor Green
    }
    elseif ($Destino -match '^\\\\' -or (Test-IsFtpPath -Path $Destino)) {
        $destinoEsFtp = Test-IsFtpPath -Path $Destino
        $tipoDestino = if ($destinoEsFtp) { "FTP" } else { "UNC" }
        Write-Host "Montando ruta $tipoDestino de destino..." -ForegroundColor Cyan
        $destinoDrive = "LLEVAR_DESTINO"
        try {
            $credDestino = if ($destinoEsFtp) { $DestinationCredentials } else { $null }
            $destinoMontado = Mount-LlevarNetworkPath -Path $Destino -Credential $credDestino -DriveName $destinoDrive
            Write-Host "✓ Destino montado: $destinoMontado" -ForegroundColor Green
        }
        catch {
            Write-Host "Error al montar destino: $($_.Exception.Message)" -ForegroundColor Red
            # Limpiar origen si fue montado
            if ($origenDrive -and (Get-PSDrive -Name $origenDrive -ErrorAction SilentlyContinue)) {
                Remove-PSDrive -Name $origenDrive -Force -ErrorAction SilentlyContinue
            }
            return
        }
    }

    # Determinar método de compresión
    if ($UseNativeZip) {
        $SevenZ = "NATIVE_ZIP"
    }
    else {
        $SevenZ = Get-7z-Llevar
    }

    $Temp = Join-Path $env:TEMP "LLEVAR_TEMP"
    if (-not (Test-Path $Temp)) { New-Item -Type Directory $Temp | Out-Null }

    # Validar que el destino (local o UNC) sea escribible
    if (-not (Test-PathWritable -Path $destinoMontado)) {
        Write-Host "Destino no es escribible. Cancelando." -ForegroundColor Red
        # Limpiar unidades montadas
        if ($origenDrive -and (Get-PSDrive -Name $origenDrive -ErrorAction SilentlyContinue)) {
            Remove-PSDrive -Name $origenDrive -Force -ErrorAction SilentlyContinue
        }
        if ($destinoDrive -and (Get-PSDrive -Name $destinoDrive -ErrorAction SilentlyContinue)) {
            Remove-PSDrive -Name $destinoDrive -Force -ErrorAction SilentlyContinue
        }
        return
    }

    if ($Iso) {
        New-LlevarIsoMain -Origen $origenMontado -Destino $destinoMontado -Temp $Temp -SevenZ $SevenZ -BlockSizeMB $BlockSizeMB -Clave $Clave
        
        # Limpiar unidades montadas
        if ($origenDrive -and (Get-PSDrive -Name $origenDrive -ErrorAction SilentlyContinue)) {
            Remove-PSDrive -Name $origenDrive -Force -ErrorAction SilentlyContinue
        }
        if ($destinoDrive -and (Get-PSDrive -Name $destinoDrive -ErrorAction SilentlyContinue)) {
            Remove-PSDrive -Name $destinoDrive -Force -ErrorAction SilentlyContinue
        }
        return
    }

    # Manejo según modo de transferencia
    if ($TransferMode -eq "Direct") {
        # ============================================
        # MODO TRANSFERENCIA DIRECTA (SIN COMPRESIÓN)
        # ============================================
        Write-Host "`nIniciando transferencia directa..." -ForegroundColor Cyan
        
        # Usar función unificada de copia
        try {
            # Si venimos del menú, usar la configuración del menú
            if ($config -and $config.Origen -and $config.Destino) {
                Write-Log "Usando configuración del menú para Copy-LlevarFiles" "INFO"
                
                # Detectar si se debe usar Robocopy (solo para Local→Local o Local→UNC)
                $useRobocopy = $false
                if ($config.Origen.Tipo -eq "Local" -and $config.Destino.Tipo -in @("Local", "UNC")) {
                    $useRobocopy = $config.RobocopyMirror -or $false
                }
                
                $copyResult = Copy-LlevarFiles -SourceConfig $config.Origen -DestinationConfig $config.Destino `
                    -SourcePath $origenMontado -ShowProgress $true -ProgressTop -1 `
                    -UseRobocopy $useRobocopy -RobocopyMirror $config.RobocopyMirror
                
                Show-Banner "✓ TRANSFERENCIA COMPLETADA" -BorderColor Green -TextColor Green
                Write-Host "Archivos copiados: $($copyResult.FileCount)" -ForegroundColor White
                Write-Host "Bytes transferidos: $([Math]::Round($copyResult.BytesCopied/1MB, 2)) MB" -ForegroundColor White
                Write-Host "Tiempo transcurrido: $([Math]::Round($copyResult.ElapsedSeconds, 2)) segundos" -ForegroundColor White
                Write-Host ""
            }
            else {
                # Si venimos de línea de comandos, construir configuraciones
                Write-Log "Construyendo configuración desde parámetros de línea de comandos" "INFO"
                
                $sourceConfig = @{
                    Tipo      = "Local"
                    Path      = $origenMontado
                    LocalPath = $origenMontado
                }
                
                $destConfig = @{
                    Tipo      = "Local"
                    Path      = $destinoMontado
                    LocalPath = $destinoMontado
                }
                
                # Detectar tipos especiales
                if ($origenEsFtp) { 
                    $sourceConfig.Tipo = "FTP"
                    $sourceConfig.FtpServer = $script:FtpSourceServer
                    $sourceConfig.FtpPort = $script:FtpSourcePort
                    $sourceConfig.FtpUser = $script:FtpSourceUser
                    $sourceConfig.FtpPassword = $script:FtpSourcePassword
                }
                if ($origenEsOneDrive) { 
                    $sourceConfig.Tipo = "OneDrive" 
                    # TODO: Obtener credenciales OneDrive si es necesario
                }
                if ($origenEsDropbox) { 
                    $sourceConfig.Tipo = "Dropbox"
                    # TODO: Obtener credenciales Dropbox si es necesario
                }
                
                if ($destinoEsFtp) { 
                    $destConfig.Tipo = "FTP"
                    $destConfig.FtpServer = $script:FtpDestinationServer
                    $destConfig.FtpPort = $script:FtpDestinationPort
                    $destConfig.FtpUser = $script:FtpDestinationUser
                    $destConfig.FtpPassword = $script:FtpDestinationPassword
                }
                if ($destinoEsOneDrive) { 
                    $destConfig.Tipo = "OneDrive"
                    # TODO: Obtener credenciales OneDrive si es necesario
                }
                if ($destinoEsDropbox) { 
                    $destConfig.Tipo = "Dropbox"
                    # TODO: Obtener credenciales Dropbox si es necesario
                }
                
                # Detectar si se debe usar Robocopy
                $useRobocopy = $false
                if ($sourceConfig.Tipo -eq "Local" -and $destConfig.Tipo -in @("Local", "UNC") -and $RobocopyMirror) {
                    $useRobocopy = $true
                }
                
                $copyResult = Copy-LlevarFiles -SourceConfig $sourceConfig -DestinationConfig $destConfig `
                    -SourcePath $origenMontado -ShowProgress $true -ProgressTop -1 `
                    -UseRobocopy $useRobocopy -RobocopyMirror $RobocopyMirror
                
                Show-Banner "✓ TRANSFERENCIA COMPLETADA" -BorderColor Green -TextColor Green
                Write-Host "Archivos copiados: $($copyResult.FileCount)" -ForegroundColor White
                Write-Host "Bytes transferidos: $([Math]::Round($copyResult.BytesCopied/1MB, 2)) MB" -ForegroundColor White
                Write-Host "Tiempo transcurrido: $([Math]::Round($copyResult.ElapsedSeconds, 2)) segundos" -ForegroundColor White
                Write-Host ""
            }
            
            Write-Host "✓ Transferencia directa completada." -ForegroundColor Green
        }
        catch {
            Write-Host "Error durante transferencia directa: $($_.Exception.Message)" -ForegroundColor Red
            Write-ErrorLog "Error en transferencia directa" $_
        }
        
        # Limpiar unidades montadas
        if ($origenDrive -and (Get-PSDrive -Name $origenDrive -ErrorAction SilentlyContinue)) {
            Remove-PSDrive -Name $origenDrive -Force -ErrorAction SilentlyContinue
        }
        if ($destinoDrive -and (Get-PSDrive -Name $destinoDrive -ErrorAction SilentlyContinue)) {
            Remove-PSDrive -Name $destinoDrive -Force -ErrorAction SilentlyContinue
        }
        
        Write-Host "`n✓ Finalizado (Modo Directo)."
        return
    }

    # ============================================
    # MODO COMPRESIÓN Y TRANSFERENCIA
    # ============================================
    Write-Host "`nIniciando compresión y transferencia..." -ForegroundColor Cyan
    
    # Si origen es OneDrive o Dropbox, descargar primero a temporal
    $origenParaComprimir = $origenMontado
    $tempOrigenCloud = $null
    
    if ($origenEsOneDrive) {
        Write-Host "Descargando desde OneDrive a carpeta temporal..." -ForegroundColor Cyan
        $tempOrigenCloud = Join-Path $env:TEMP "LLEVAR_ONEDRIVE_ORIGEN"
        if (Test-Path $tempOrigenCloud) {
            Remove-Item $tempOrigenCloud -Recurse -Force
        }
        New-Item -Type Directory $tempOrigenCloud | Out-Null
        
        Receive-OneDriveFolder -OneDrivePath "root:${origenMontado}:" -LocalFolder $tempOrigenCloud
        $origenParaComprimir = $tempOrigenCloud
    }
    elseif ($origenEsDropbox) {
        Write-Host "Descargando desde Dropbox a carpeta temporal..." -ForegroundColor Cyan
        $tempOrigenCloud = Join-Path $env:TEMP "LLEVAR_DROPBOX_ORIGEN"
        if (Test-Path $tempOrigenCloud) {
            Remove-Item $tempOrigenCloud -Recurse -Force
        }
        New-Item -Type Directory $tempOrigenCloud | Out-Null
        
        Receive-DropboxFolder -RemotePath $origenMontado -LocalFolder $tempOrigenCloud -Token $Global:DropboxToken
        $origenParaComprimir = $tempOrigenCloud
    }
    
    $compressionResult = Compress-Folder $origenParaComprimir $Temp $SevenZ $Clave $BlockSizeMB
    $blocks = $compressionResult.Files
    $compressionType = $compressionResult.CompressionType

    $installerScript = New-InstallerScript -Destino $destinoMontado -Temp $Temp -CompressionType $compressionType

    # Si destino es OneDrive o Dropbox, subir bloques
    if ($destinoEsOneDrive) {
        Write-Host "`nSubiendo bloques a OneDrive..." -ForegroundColor Cyan
        
        $totalBlocks = $blocks.Count
        $currentBlock = 0
        
        foreach ($block in $blocks) {
            $currentBlock++
            $fileName = [System.IO.Path]::GetFileName($block)
            Write-Host "[$currentBlock/$totalBlocks] Subiendo: $fileName" -ForegroundColor Gray
            Send-OneDriveFile -LocalPath $block -RemotePath $destinoMontado
        }
        
        # Subir instalador
        if ($installerScript -and (Test-Path $installerScript)) {
            Write-Host "Subiendo INSTALAR.ps1..." -ForegroundColor Gray
            Send-OneDriveFile -LocalPath $installerScript -RemotePath $destinoMontado
        }
        
        # Subir 7-Zip si es necesario
        if ($SevenZ -and $compressionType -ne "NATIVE_ZIP" -and (Test-Path $SevenZ)) {
            Write-Host "Subiendo 7z.exe..." -ForegroundColor Gray
            Send-OneDriveFile -LocalPath $SevenZ -RemotePath $destinoMontado
        }
        
        Write-Host "`n✓ Todos los archivos subidos a OneDrive" -ForegroundColor Green
    }
    elseif ($destinoEsDropbox) {
        Write-Host "`nSubiendo bloques a Dropbox..." -ForegroundColor Cyan
        
        $totalBlocks = $blocks.Count
        $currentBlock = 0
        
        foreach ($block in $blocks) {
            $currentBlock++
            $fileName = [System.IO.Path]::GetFileName($block)
            $remotePath = "$destinoMontado/$fileName".Replace('//', '/')
            Write-Host "[$currentBlock/$totalBlocks] Subiendo: $fileName" -ForegroundColor Gray
            Send-DropboxFile -LocalPath $block -RemotePath $remotePath -Token $Global:DropboxToken
        }
        
        # Subir instalador
        if ($installerScript -and (Test-Path $installerScript)) {
            Write-Host "Subiendo INSTALAR.ps1..." -ForegroundColor Gray
            $installerName = [System.IO.Path]::GetFileName($installerScript)
            $remotePath = "$destinoMontado/$installerName".Replace('//', '/')
            Send-DropboxFile -LocalPath $installerScript -RemotePath $remotePath -Token $Global:DropboxToken
        }
        
        # Subir 7-Zip si es necesario
        if ($SevenZ -and $compressionType -ne "NATIVE_ZIP" -and (Test-Path $SevenZ)) {
            Write-Host "Subiendo 7z.exe..." -ForegroundColor Gray
            $remotePath = "$destinoMontado/7z.exe".Replace('//', '/')
            Send-DropboxFile -LocalPath $SevenZ -RemotePath $remotePath -Token $Global:DropboxToken
        }
        
        Write-Host "`n✓ Todos los archivos subidos a Dropbox" -ForegroundColor Green
    }
    elseif ($config -and $config.Destino -and $config.Destino.Tipo -eq "Floppy") {
        # Modo diskettes
        Write-Host "`nCopiando a diskettes..." -ForegroundColor Cyan
        
        $floppySuccess = Copy-ToFloppyDisks `
            -SourcePath $origenParaComprimir `
            -TempDir $Temp `
            -SevenZPath $SevenZ `
            -Password $Clave `
            -VerifyDisks
        
        if (-not $floppySuccess) {
            Write-Host "✗ Error copiando a diskettes" -ForegroundColor Red
            # No limpiar archivos temporales en caso de error
            return
        }
    }
    else {
        Copy-BlocksToUSB -Blocks $blocks -InstallerPath $installerScript -SevenZPath $SevenZ -CompressionType $compressionType -DestinationPath $destinoMontado -IsFtp $destinoEsFtp
    }
    
    # Limpiar temporal de cloud origen si existe
    if ($tempOrigenCloud -and (Test-Path $tempOrigenCloud)) {
        Write-Host "`nLimpiando descarga temporal de cloud..." -ForegroundColor Cyan
        Remove-Item $tempOrigenCloud -Recurse -Force -ErrorAction SilentlyContinue
    }

    # Limpiar archivos temporales después de transferir
    Write-Host "`nLimpiando archivos temporales..." -ForegroundColor Cyan
    try {
        if (Test-Path $Temp) {
            Remove-Item -Path $Temp -Recurse -Force -ErrorAction Stop
            Write-Host "✓ Archivos temporales eliminados de: $Temp" -ForegroundColor Green
        }
    }
    catch {
        Write-Host "Advertencia: No se pudieron eliminar algunos archivos temporales: $($_.Exception.Message)" -ForegroundColor Yellow
        Write-ErrorLog "Error al limpiar archivos temporales" $_
    }

    # Limpiar unidades montadas
    if ($origenDrive -and (Get-PSDrive -Name $origenDrive -ErrorAction SilentlyContinue)) {
        Remove-PSDrive -Name $origenDrive -Force -ErrorAction SilentlyContinue
    }
    if ($destinoDrive -and (Get-PSDrive -Name $destinoDrive -ErrorAction SilentlyContinue)) {
        Remove-PSDrive -Name $destinoDrive -Force -ErrorAction SilentlyContinue
    }

    Write-Host "`n✓ Finalizado (Modo Comprimido)."
}
catch {
    Write-ErrorLog "Error en ejecución." $_
    Write-Host "Ocurrió un error. Revise el log en: $Global:LogFile" -ForegroundColor Red
        
    # Limpiar unidades montadas en caso de error
    if ($origenDrive -and (Get-PSDrive -Name $origenDrive -ErrorAction SilentlyContinue)) {
        Remove-PSDrive -Name $origenDrive -Force -ErrorAction SilentlyContinue
    }
    if ($destinoDrive -and (Get-PSDrive -Name $destinoDrive -ErrorAction SilentlyContinue)) {
        Remove-PSDrive -Name $destinoDrive -Force -ErrorAction SilentlyContinue
    }
}
